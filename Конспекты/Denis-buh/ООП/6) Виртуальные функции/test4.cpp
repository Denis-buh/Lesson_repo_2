

/*
Виртуальные функции обьявляются в классе родители и имеют приписку virtual 
Отличие от переопределения в том, что выбор метода для виртуальных методов 
    осуществляется на этапе выполнения (когда уже известен тип обьекта)
Выртуальная функция вызывается через указатель или ссылку
    на базовый класс. (можно и напрямую, но тогда не будет динамики)

Правила:
    1) Виртуальные методы наследуются (их можно переопределять)
    2) если виртуальный метод переопределен в производном классе, то обьекты 
    этого класса могут получить доступ к варианту метода базового класса с помощью 
    видимости
    3) Виртуальный метод не может быть статическим но может быть дружественным

Виртуальная функция, объявленная в базовом классе иерархии порождения, 
    может совсем  не использоваться для объектов этого класса, и даже  не иметь определения. 
Для выделения этой особенности ее приравнивают к нулю. В этом случае функция называется чисто виртуальной.
Класс,  содержащий  одну или более чисто виртуальных функций, называется абстрактным. 
Абстрактный класс может использоваться только в роли  базового класса для порождений потомков. 
Создавать объекты абстрактного класса и использовать его в качестве типа значения, 
    возвращаемого функцией, и типов параметров функции нельзя. 

*/

#include <iostream>
#include <math.h>
using namespace std;

const float Pi=3.1435;

class Shape{
protected:
    float radius, height;
public:            
    Shape (float r, float h) { radius = r; height = h;}
    // Не определено, но компилятору на это пох
    virtual float S() = 0;
    virtual float V() = 0;   
};

class Cylinder : public Shape {
public:
    Cylinder(float r, float h) : Shape( r, h) { }
    virtual float S( ) { return 2 * Pi * radius *(radius +height); }
    virtual float V( ) { return Pi * radius * radius * height; }
};

class Cone : public Shape {
public:
    Cone(float r, float h) : Shape(r, h) { }
    virtual float S( ) { return Pi *radius*(radius +sqrt(radius*radius+height*height)); }
    virtual float V( ) { return Pi *radius*radius*height/3;}
};

int main(){
    // Shape s(5,10); - За это дадут по ебалу 
    Cylinder ci(2,10);
    Cone co(2, 5);
    Shape *p;
    cout<<"for shape s="<<p->S( ) <<"p="<< p->V( );
    p = &ci;
    cout<< "for cilinder s="<< p->S( )<<"p="<<p->V();
    p = &co;      
    cout<< "for cone s="<< p->S()<<"p="<<p->V();
    system("pause");
    return 0;
}

